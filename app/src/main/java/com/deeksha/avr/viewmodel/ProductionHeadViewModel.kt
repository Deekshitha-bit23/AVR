package com.deeksha.avr.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.deeksha.avr.model.DepartmentBudget
import com.deeksha.avr.model.Project
import com.deeksha.avr.model.User
import com.deeksha.avr.model.UserRole
import com.deeksha.avr.repository.AuthRepository
import com.deeksha.avr.repository.ProjectRepository
import com.deeksha.avr.repository.NotificationRepository
import com.google.firebase.Timestamp
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ProductionHeadViewModel @Inject constructor(
    private val authRepository: AuthRepository,
    private val projectRepository: ProjectRepository,
    private val notificationRepository: NotificationRepository
) : ViewModel() {
    
    // UI States
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    private val _successMessage = MutableStateFlow<String?>(null)
    val successMessage: StateFlow<String?> = _successMessage.asStateFlow()
    
    // User Creation States
    private val _availableUsers = MutableStateFlow<List<User>>(emptyList())
    val availableUsers: StateFlow<List<User>> = _availableUsers.asStateFlow()
    
    private val _availableApprovers = MutableStateFlow<List<User>>(emptyList())
    val availableApprovers: StateFlow<List<User>> = _availableApprovers.asStateFlow()
    
    // Project Creation States
    private val _departmentBudgets = MutableStateFlow<List<DepartmentBudget>>(emptyList())
    val departmentBudgets: StateFlow<List<DepartmentBudget>> = _departmentBudgets.asStateFlow()
    
    private val _totalBudget = MutableStateFlow(0.0)
    val totalBudget: StateFlow<Double> = _totalBudget.asStateFlow()
    
    private val _totalAllocated = MutableStateFlow(0.0)
    val totalAllocated: StateFlow<Double> = _totalAllocated.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val users = authRepository.getAllUsers()
                _availableUsers.value = users.filter { it.role == UserRole.USER }
                _availableApprovers.value = users.filter { it.role == UserRole.APPROVER }
            } catch (e: Exception) {
                _error.value = "Failed to load users: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun createUser(phoneNumber: String, fullName: String, role: UserRole) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val user = User(
                    uid = "", // Will be set by Firebase
                    phone = phoneNumber.replace("+91", "").trim(),
                    name = fullName,
                    role = role,
                    email = "",
                    createdAt = System.currentTimeMillis(),
                    isActive = true
                )
                
                val result = authRepository.createUserByAdmin(user)
                if (result.isSuccess) {
                    _successMessage.value = "User created successfully!"
                    loadUsers() // Refresh user list
                } else {
                    _error.value = result.exceptionOrNull()?.message ?: "Failed to create user"
                }
            } catch (e: Exception) {
                _error.value = "Error creating user: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun createProject(
        projectName: String,
        description: String,
        startDate: Timestamp,
        endDate: Timestamp?,
        totalBudget: Double,
        managerId: String,
        teamMemberIds: List<String>,
        departmentBudgets: List<DepartmentBudget>
    ) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val budgetMap = departmentBudgets.associate { 
                    it.departmentName to it.allocatedBudget 
                }
                
                val project = Project(
                    id = "", // Will be generated by Firestore
                    name = projectName,
                    description = description,
                    budget = totalBudget,
                    spent = 0.0,
                    startDate = startDate,
                    endDate = endDate,
                    status = "ACTIVE",
                    managerId = managerId,
                    teamMembers = teamMemberIds,
                    createdAt = Timestamp.now(),
                    updatedAt = Timestamp.now(),
                    code = generateProjectCode(projectName),
                    departmentBudgets = budgetMap
                )
                
                val result = projectRepository.createProject(project)
                if (result.isSuccess) {
                    // Send notifications to assigned team members using the project data we created
                    sendProjectAssignmentNotifications(project, managerId, teamMemberIds)
                    
                    _successMessage.value = "Project created successfully!"
                    clearProjectForm()
                } else {
                    _error.value = result.exceptionOrNull()?.message ?: "Failed to create project"
                }
            } catch (e: Exception) {
                _error.value = "Error creating project: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun addDepartmentBudget(departmentName: String, budget: Double) {
        val currentList = _departmentBudgets.value.toMutableList()
        
        // Check if department already exists
        val existingIndex = currentList.indexOfFirst { it.departmentName == departmentName }
        if (existingIndex >= 0) {
            currentList[existingIndex] = DepartmentBudget(departmentName, budget)
        } else {
            currentList.add(DepartmentBudget(departmentName, budget))
        }
        
        _departmentBudgets.value = currentList
        calculateTotalAllocated()
    }
    
    fun removeDepartmentBudget(departmentName: String) {
        val currentList = _departmentBudgets.value.toMutableList()
        currentList.removeAll { it.departmentName == departmentName }
        _departmentBudgets.value = currentList
        calculateTotalAllocated()
    }
    
    fun updateTotalBudget(budget: Double) {
        _totalBudget.value = budget
    }
    
    private fun calculateTotalAllocated() {
        val total = _departmentBudgets.value.sumOf { it.allocatedBudget }
        _totalAllocated.value = total
    }
    
    private fun generateProjectCode(projectName: String): String {
        val words = projectName.split(" ")
        return if (words.size >= 2) {
            "${words[0].take(2).uppercase()}${words[1].take(1).uppercase()}"
        } else {
            projectName.take(3).uppercase()
        }
    }
    
    private fun clearProjectForm() {
        _departmentBudgets.value = emptyList()
        _totalBudget.value = 0.0
        _totalAllocated.value = 0.0
    }
    
    fun clearError() {
        _error.value = null
    }
    
    fun clearSuccessMessage() {
        _successMessage.value = null
    }
    
    private fun sendProjectAssignmentNotifications(
        project: Project,
        managerId: String,
        teamMemberIds: List<String>
    ) {
        viewModelScope.launch {
            try {
                // Get all users to determine their roles
                val allUsers = authRepository.getAllUsers()
                
                // Send notification to manager (approver)
                val manager = allUsers.find { it.uid == managerId }
                if (manager != null) {
                    notificationRepository.createProjectAssignmentNotification(
                        recipientId = managerId,
                        recipientRole = manager.role.name,
                        projectId = project.id,
                        projectName = project.name,
                        assignedRole = "Project Manager"
                    )
                }
                
                // Send notifications to team members
                teamMemberIds.forEach { memberId ->
                    val member = allUsers.find { it.uid == memberId }
                    if (member != null) {
                        notificationRepository.createProjectAssignmentNotification(
                            recipientId = memberId,
                            recipientRole = member.role.name,
                            projectId = project.id,
                            projectName = project.name,
                            assignedRole = "Team Member"
                        )
                    }
                }
                
                android.util.Log.d("ProductionHeadViewModel", "✅ Sent assignment notifications for project: ${project.name}")
            } catch (e: Exception) {
                android.util.Log.e("ProductionHeadViewModel", "❌ Error sending assignment notifications: ${e.message}")
            }
        }
    }
} 